---
title: 2020-4-30 leetcode
tags: leetcode，算法，数据结构
---

## **数据结构**    
+ 存储方式：顺序存储（数组）和链式存储（链表），链式存储不能随机访问。      
+ 遍历+访问：线性访问（for/while为代表）和迭代访问（递归为代表），访问是增删改查。         

## **递归**     
+ 过程实现：递归调用和普通函数调用是类似的。每次函数调用都有一个分离的活动帧保存当前的函数参数等栈信息，当前函数挂起，进入下一个函数调用。
+ 组成部分：基础条件base case返回固定值和递归条件recursive case。                     
+ 应用例子：
	1）阶乘：n！=（n-1）！，表示n个数排列组合的所有情况。     
	2）英语规则：
	3）二分查找：通过折半递归查找目标值，如线性数组，缩小递归搜索范围。     
	4）文件系统：可以递归计算文件目录的大小，当前目录/文件大小+所有子目录的目录/文件大小。归纳为树的遍历。       
+ 线性递归：每次递归只调用一次递归函数。如阶乘例子和二分查找例子（二分查找只会走其中一个分支递归搜索）。递归数组求和以及递归反转数组都是线性递归的例子。            
+ 二叉递归：每次递归调用2次递归函数。  数组元素的累计和也可以分解为二叉递归的解法。空间复杂度和时间复杂度的计算？      
+ 多重递归：每次递归调用多次递归函数。如递归计算目录的大小。  
+ 递归函数设计： 考虑带参数的递归函数，参数对于分解子问题起到决定性作用。          
+ 注意区别低效的递归：
+ 注意无限递归死循环：没有base case导致无法结束递归。避免无限递归必须意识到每次递归操作会趋向base case。        
+ 消除尾递归：利用栈转换成非递归的形式节省函数调用内存消耗。将线性递归转换为迭代方式？                                  


## **树**     
+ 前序遍历：先构造完全二叉树，从上到下和从左到右遍历，第1次遇到节点的时候将节点打印出来。     
+ 中序遍历：先构造完全二叉树，从上到下和从左到右遍历，第2次遇到节点的时候将节点打印出来。     
+ 后序遍历：先构造完全二叉树，从上到下和从左到右遍历，最后1次遇到节点的时候将节点打印出来。       
+ 前序后序遍历不能还原二叉树：中序前序或者中序后序才能还原二叉树，因为前序后序无法确认左右子树，只有中序能确认左右子树。          
+ 二叉树的左视图：首先要确认每个节点在哪层，然后通过前序或者层级遍历，并且用数组记录该层是否被访问过，先序或者层级遍历的时候，就可以打印左视图的节点。      
+ 确定节点属于哪一层：      
     

## **遍历（非递归）**    
+ 前序遍历     
   1）思路：每个节点D，都是出栈D（打印节点），然后按照R-->L的方式入栈，出栈的顺序就是前序遍历。       
   2）算法：利用1个栈，出栈1个节点，入栈2个子节点，先入栈右子节点，再入栈左子节点，出栈的顺序就是遍历的顺序。     
+ 中序遍历     
	1）思路：每个节点D，都是出栈最左节点（打印节点），然后指向节点的右子树，继续出栈最左节点，出栈的顺序就是中序遍历。     
	2）算法：利用1个栈和当前指针，左子节点不为空则入栈，找到最左子节点，就出栈，然后将当前赋值为出栈节点的右子节点，当前指针不为空则继续找左子节点，为空则出栈子节点，重复将当前指针赋值为出栈节点的右子节点。出栈的顺序就是遍历的顺序。         
+ 后序遍历       
	1）思路：      
		双栈法：前序遍历的变种，每个节点D，都是入栈D，然后按照R-->L的方式入栈，将出栈结果存放到另外一个栈中，实现逆序打印，出栈的顺序就是后序遍历。       
		单栈法1：出栈的时候检查右子树是否已经被访问了，用pair<Node,int>表示节点是否被访问过（1表示访问左子树，2表示访问右子树）。    
		单栈法2：前序遍历的变种。按照前序遍历，但是先入左子树，再入右子树，最后将结果逆序打印。                    
	2）利用2个栈S1和S2，根节点开始出栈，S1出栈的节点放到S2，然后将出栈节点的左右子节点放到S1中，然后再循环出栈1个节点。       
+ 层级遍历       
	1）思路：      
		BFS，队列方式，将树节点按照每层放入队列，每取出一个节点，就将该节点下一层的子节点放入队列中。           
		DFS，递归方式，在当前层存放节点，然后递归遍历下一层的左子树和右子树，每遍历一层就创建结果集，存放当前层的节点。      
	2）算法：利用队列，每出队一个节点，就将该节点的左右子节点放入队列中，出队的顺序表示层级遍历的顺序，原则是出队1个节点，入队2个子节点的节奏循环操作。     
+ 结论        
   1）利用栈完成树节点遍历，通过控制子节点入栈和出栈的顺序完成树的遍历。层序遍历利用队列。     
   2）二叉树非递归遍历属于深度优先搜索DFS，和图的DFS遍历类似，注意图还有广度优先搜索BFS。             
   3）二叉树层级遍历属于广度优先搜索BFS       
   4）DFS：深度优先，想象栈为垂直类型，最先的元素在栈底，所以适合DFS？     
   5）BFS：广度优先，想象队列为水平类型，先进先出，所以适合BFS?       
     

## **参考**      
+ leetcode经典分析： https://github.com/labuladong/fucking-algorithm            
+ 著名经典教材：《算法（第4版）》      
+ 著名经典教材：《Data Structures and Algorithms in Java 6》     
+ Youtub视频教程：TECH DOSE系列，搜索tree        
   https://www.youtube.com/watch?v=K2ybI-GEHSY&list=PLEJXowNB4kPzqcnf9CnjEcgP7r5LaSijB&index=1            
+ 数据结构入门：《大话数据结构》     
+ 数据结构和算法：https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode 题解 - 目录.md     
+ 算法和数据结构书籍推荐：https://www.zhihu.com/question/21628833      
    