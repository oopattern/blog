---
title: 2020-4-30 leetcode
tags: leetcode，算法，数据结构
---

## **数据结构**    
+ 存储方式：顺序存储（数组）和链式存储（链表），链式存储不能随机访问。      
+ 遍历+访问：线性访问（for/while为代表）和迭代访问（递归为代表），访问是增删改查。         

## **递归**     
+ 过程实现：递归调用和普通函数调用是类似的。每次函数调用都有一个分离的活动帧保存当前的函数参数等栈信息，当前函数挂起，进入下一个函数调用。
+ 组成部分：基础条件base case返回固定值和递归条件recursive case。 
+ 关键要素：结束条件（第一行return）、规模更小子问题、父问题和子问题不应该有交集。                           
+ 应用例子：
	1）阶乘：n！=（n-1）！，表示n个数排列组合的所有情况。     
	2）英语规则：
	3）二分查找：通过折半递归查找目标值，如线性数组，缩小递归搜索范围。     
	4）文件系统：可以递归计算文件目录的大小，当前目录/文件大小+所有子目录的目录/文件大小。归纳为树的遍历。       
+ 线性递归：每次递归只调用一次递归函数。如阶乘例子和二分查找例子（二分查找只会走其中一个分支递归搜索）。递归数组求和以及递归反转数组都是线性递归的例子。            
+ 二叉递归：每次递归调用2次递归函数。  数组元素的累计和也可以分解为二叉递归的解法。空间复杂度和时间复杂度的计算？      
+ 多重递归：每次递归调用多次递归函数。如递归计算目录的大小。  
+ 递归函数设计： 考虑带参数的递归函数，参数对于分解子问题起到决定性作用。          
+ 注意区别低效的递归：       
   1）判断序列元素唯一性例子中，重复冗余的判断导致指数级的时间复杂度？             
   2）Fibonacci数列也可能存在低效递归？第n个Fibonacci数字F(n)=F(n-1)+F(n-2)，二叉递归，计算F(n-1)的时候，F(n-2)已经计算过了，计算F(n)的时候会再计算一次，导致计算的时间复杂度为指数级。消除这种情况的方法是把每次计算的结果保存下来，下次直接使用，采用数组保存每次序列的结果，最后返回一个数组，取出最后一个元素。         
   3）结论：需要注意递归函数调用的次数，尽量控制由n递减到1，避免重复冗余的递归调用（如计算F(n)依赖F(n-1)和F(n-2)，这样F(n-1)又重复计算了F(n-2)）,导致指数级的时间复杂度。       
+ 注意无限递归死循环：没有base case导致无法结束递归。避免无限递归必须意识到每次递归操作会趋向base case。        
+ 尾递归优化：尾递归主要对栈内存空间进行优化。一般递归需要回溯，尾递归不用回溯。利用栈转换成非递归的形式节省函数调用内存消耗。将线性递归转换为迭代方式？                                  


## **树**     
+ 前序遍历：先构造完全二叉树，从上到下和从左到右遍历，第1次遇到节点的时候将节点打印出来。     
+ 中序遍历：先构造完全二叉树，从上到下和从左到右遍历，第2次遇到节点的时候将节点打印出来。     
+ 后序遍历：先构造完全二叉树，从上到下和从左到右遍历，最后1次遇到节点的时候将节点打印出来。       
+ 前序后序遍历不能还原二叉树：中序前序或者中序后序才能还原二叉树，因为前序后序无法确认左右子树，只有中序能确认左右子树。          
+ 二叉树的左视图：首先要确认每个节点在哪层，然后通过前序或者层级遍历，并且用数组记录该层是否被访问过，先序或者层级遍历的时候，就可以打印左视图的节点。      
+ 确定节点属于哪一层：      
     

## **遍历（非递归）**    
+ 前序遍历     
   1）思路：每个节点D，都是出栈D（打印节点），然后按照R-->L的方式入栈，出栈的顺序就是前序遍历。       
   2）算法：利用1个栈，出栈1个节点，入栈2个子节点，先入栈右子节点，再入栈左子节点，出栈的顺序就是遍历的顺序。     
+ 中序遍历     
	1）思路：每个节点D，都是出栈最左节点（打印节点），然后指向节点的右子树，继续出栈最左节点，出栈的顺序就是中序遍历。     
	2）算法：利用1个栈和当前指针，左子节点不为空则入栈，找到最左子节点，就出栈，然后将当前赋值为出栈节点的右子节点，当前指针不为空则继续找左子节点，为空则出栈子节点，重复将当前指针赋值为出栈节点的右子节点。出栈的顺序就是遍历的顺序。         
+ 后序遍历       
	1）思路：      
		双栈法：前序遍历的变种，每个节点D，都是入栈D，然后按照R-->L的方式入栈，将出栈结果存放到另外一个栈中，实现逆序打印，出栈的顺序就是后序遍历。       
		单栈法1：出栈的时候检查右子树是否已经被访问了，用pair<Node,int>表示节点是否被访问过（1表示访问左子树，2表示访问右子树）。    
		单栈法2：前序遍历的变种。按照前序遍历，但是先入左子树，再入右子树，最后将结果逆序打印。                    
	2）利用2个栈S1和S2，根节点开始出栈，S1出栈的节点放到S2，然后将出栈节点的左右子节点放到S1中，然后再循环出栈1个节点。       
+ 层级遍历       
	1）思路：      
		BFS，队列方式，将树节点按照每层放入队列，每取出一个节点，就将该节点下一层的子节点放入队列中。           
		DFS，递归方式，在当前层存放节点，然后递归遍历下一层的左子树和右子树，每遍历一层就创建结果集，存放当前层的节点。      
	2）算法：利用队列，每出队一个节点，就将该节点的左右子节点放入队列中，出队的顺序表示层级遍历的顺序，原则是出队1个节点，入队2个子节点的节奏循环操作。     
+ 结论        
   1）利用栈完成树节点遍历，通过控制子节点入栈和出栈的顺序完成树的遍历。层序遍历利用队列。     
   2）二叉树非递归遍历属于深度优先搜索DFS，和图的DFS遍历类似，注意图还有广度优先搜索BFS。             
   3）二叉树层级遍历属于广度优先搜索BFS       
   4）DFS：深度优先，想象栈为垂直类型，最先的元素在栈底，所以适合DFS？     
   5）BFS：广度优先，想象队列为水平类型，先进先出，所以适合BFS?      
   
## **二分法**   
+ 应用场景：寻找一个数、寻找左侧边界、寻找右侧边界       
+ 框架流程： 
   1）搜索边界：left=0, right=nums.length - 1        
   2）搜索区间：[left, right]，注意两端都是闭区间           
   3）while条件： while (left <= right)      
   4）调整左右搜索范围：left = mid + 1，right = mid - 1       
   5）返回条件：满足 target  = nums[mid] 直接返回，不满足直接返回 -1         
+ 搜索左右边界：      
  1）满足 target = nums[mid] 时不返回，继续锁定左侧边界或者右侧边界。     
  2）最后检查left越界或者right越界的情况。      
+ 注意事项：      
  1）二分查找代码不要出现else，全部展开成else if     
  2）将搜索区间全都统一成两端都闭，只要改target = nums[mid] 条件处的代码和返回的逻辑，可以作为二分法通用的模板。        

   
##  **动态规划**      
+ 动态规划要素：重叠子问题、最优子结构、状态转移方程（状态n和状态n-1的关系叫状态转移）。       
+ 一般形式：求最值：最长递增子序列、最小编辑距离、凑零钱问题。        
+ 核心：穷举。对于重叠子问题，需要备忘录或者DP Table来优化穷举。       
+ 思考状态转移方程（最难实现）：明确[状态] --> 定义dp数组/函数的含义 --> 明确[选择] --> 明确base case。   
+ 斐波那契数列： 
   1）考虑重叠子问题。f(20) = f(19) + f(18)，然后计算f(19)的时候f(18)又会重复计算。导致效率十分低下。         
   2）考虑自顶而下的画递归树，可以分析递归算法是否低效（是否包含重复计算）。      
   3）递归时间复杂度计算：子问题个数乘以一个子问题需要的时间。     
   4）带备忘录的递归：子问题的答案记录在备忘录（数组）中，遇到子问题先去备忘录查询是否已经计算过。       
   5）递归是自顶向下，动态规划是自底向上，用DP Table完成自底向上数值的计算，可以用数值迭代方式取代递归方式。     
+ T5 最长回文子串：     
+ T516 最长回文子序列：        
+ T322 凑零钱问题：考虑如何列出状态转移方程。f(n) = min{f(n-coin)+1, coin in coins}          
+ T300 最长递增子序列问题：f(i) = max{f(i), 1 + f(j)} | nums[i] > nums[j], f(i)表示以i索引结尾的子序列    
+ T1143 最长公共子序列问题：                  
+ 扔鸡蛋问题：        
+ 爬楼梯问题：          

## **参考**      
+ leetcode经典分析： https://github.com/labuladong/fucking-algorithm            
+ 著名经典教材：《算法（第4版）》      
+ 著名经典教材：《Data Structures and Algorithms in Java 6》，递归讲解深刻       
+ Youtub视频教程：TECH DOSE系列，搜索tree        
   https://www.youtube.com/watch?v=K2ybI-GEHSY&list=PLEJXowNB4kPzqcnf9CnjEcgP7r5LaSijB&index=1            
+ 数据结构入门：《大话数据结构》     
+ 数据结构和算法：https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode 题解 - 目录.md     
+ 算法和数据结构书籍推荐：https://www.zhihu.com/question/21628833      
+ 高频题目整理：https://github.com/xizhengszhang/Leetcode_company_frequency         
    