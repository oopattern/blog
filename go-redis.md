---
title: 2019-12-21 go-redis 
tags: go,reids
renderNumberedHeading: true
grammar_cjkRuby: true
---


**命令类图**
**说明：** 命令类图展示了redis命令的处理方式。
1、cmdable声明为函数，是因为所有的redis命令请求都是执行发包收包解包的操作。
2、Cmder声明为接口，是因为不同的命令(Ping/HSet)要实现不同的回复解析，baseCmd表示所有命令相同的属性。
 ![enter description here](./images/1576983804976.png)
 
 **客户端类图**
 **说明：** 客户端类图展示了客户端和连接池的关系。
 1、baseClient封装了客户端基本的连接配置和连接池接口。
 2、Pooler接口提供了操作访问连接池的操作，采用接口的方式是为了让客户端能访问操作连接池，并且不用关心连接池管理的具体实现细节。
 ![enter description here](./images/1577010897515.png)
 
 **连接池**
 **说明：** go-redis内部实现了连接池，一个进程中，客户端实例在各个协程可以并发安全共用。
 1、每个客户端实例维护一个连接池，进程只需要一个客户端实例（各个协程共享）。
 2、如果每个客户端实例维护一个连接，进程中大量协程(1w+)会大量消耗redis的连接数（超过上限就连不上redis了）。
 3、r3c每个线程一个客户端实例（一个连接），各个线程不能共享同一个客户端实例，每个实例不需要用锁来同步访问。
 3、go-redis连接池采用锁机制，每个协程每次redis请求，会从连接池获取一个可用的连接（通过锁同步）。
 3、kafka写代理也使用了连接池，目的是将收敛连接kafka-broker的连接，防止过多的进程连接kafka-broker，避免对kafka集群造成连接的压力。
 3、示例： 
 1） 主协程请求Incr命令，延时等待，并发启动1w个工作协程，采用同一个客户端实例，每个工作协程请求Incr命令并延时等待，然后查看客户端连接数。
 ![enter description here](./images/1576989745456.png)
 2）如果客户端实例的连接池一段时间没有数据请求，会自动释放和redis的连接。
 ![enter description here](./images/1576990237001.png)
 3）如果大量协程使用同一个客户端实例频繁请求redis命令，是否会存在某个协程的redis命令无法执行？
 每个协程能够分配CPU的执行时间，理论上每个协程都能执行redis命令，但是redis-server是单线程的，每次只能处理一个命令。

